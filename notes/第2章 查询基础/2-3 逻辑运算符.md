# 2-3 逻辑运算符

[toc]

## `NOT` 运算符

**代码清单 2-31　向代码清单 2-30 的查询条件中添加 `NOT` 运算符**

```SQL
SELECT product_name, product_type, sale_price
  FROM Product
 WHERE NOT sale_price >= 1000;
```

> `WHERE`子句指定的查询条件（`sale_price < 1000` ）是等价的 

![NeatReader-1660383495863](D:/GitRep/SQL/notes/%E7%AC%AC2%E7%AB%A0%20%E6%9F%A5%E8%AF%A2%E5%9F%BA%E7%A1%80/2-3%20%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6.assets/NeatReader-1660383495863-16603835253952.png)

> `NOT` 运算符用来否定某一条件，但是不能滥用。

## `AND` 运算符和 `OR` 运算符

从 `Product` 表中选取出“商品种类为厨房用具（`product_type = '厨房用具'` ），**并且** 销售单价大于等于 3000 日元（`sale_price >= 3000` ）的商品”的查询

```SQL
SELECT product_name, purchase_price
  FROM Product
 WHERE product_type = '厨房用具'
   AND sale_price >= 3000;
```

> 左侧的圆圈代表符合查询条件“商品种类为厨房用具”的商品，右侧的圆圈代表符合查询条件“销售单价大于等于 3000 日元”的商品。两个圆重合的部分（同时满足两个查询条件的商品）就是通过 `AND` 运算符能够选取出的记录。

![图书封面](D:/GitRep/SQL/notes/%E7%AC%AC2%E7%AB%A0%20%E6%9F%A5%E8%AF%A2%E5%9F%BA%E7%A1%80/2-3%20%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6.assets/Image00047-16603839471176.gif)

---

选取出“商品种类为厨房用具（`product_type = '厨房用具'` ），**或者** 销售单价大于等于 3000 日元（`sale_price >= 3000` ）的商品”的查询条件中使用了 `OR` 运算符

```SQL
SELECT product_name, purchase_price
  FROM Product
 WHERE product_type = '厨房用具'
    OR sale_price >= 3000;
```

> 包含在左侧的圆圈（商品种类为厨房用具的商品）或者右侧的圆圈（销售单价大于等于 3000 日元的商品）中的部分（两个查询条件中满足任何一个的商品）就是通过 `OR` 运算符能够取出的记录。

![{%}](D:/GitRep/SQL/notes/%E7%AC%AC2%E7%AB%A0%20%E6%9F%A5%E8%AF%A2%E5%9F%BA%E7%A1%80/2-3%20%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6.assets/Image00048-166038421727911.gif)

## 通过括号强化处理

> “商品种类为办公用品”
>
> 并且
>
> “登记日期是 2009 年 9 月 11 日或者 2009 年 9 月 20 日”

满足上述查询条件的商品（`product_name` ）只有“打孔器”。

**代码清单 2-35　将查询条件原封不动地写入条件表达式**

```sql
SELECT product_name, product_type, regist_date
  FROM Product
 WHERE product_type = '办公用品'
   AND regist_date = '2009-09-11'
    OR regist_date = '2009-09-20';
```

**执行结果**

```sql
product_name  | product_type | regist_date
---------------+--------------+------------
 T恤衫         | 衣服         | 2009-09-20
 打孔器        | 办公用品     | 2009-09-11
 菜刀          | 厨房用具     | 2009-09-20
 叉子          | 厨房用具     | 2009-09-20
```

**不想要的 T 恤衫、菜刀和叉子也被选出来了，真是头疼呀。到底为什么会得到这样的结果呢？**

这是 **`AND` 运算符优先于 `OR` 运算符** 所造成的。

```sql
「product_type = '办公用品' AND regist_date = '2009-09-11'」
 OR
 「regist_date = '2009-09-20'」
```

**代码清单 2-36　通过使用括号让 `OR` 运算符先于 `AND` 运算符执行**

```sql
SELECT product_name, product_type, regist_date
  FROM Product
 WHERE product_type = '办公用品'
   AND (   regist_date = '2009-09-11'
        OR regist_date = '2009-09-20');
```

## 逻辑运算符和真值

> 上一节介绍的比较运算符会把运算结果以真值的形式进行返回。比较结果成立时返回真（`TRUE` ），比较结果不成立时返回假（`FALSE` ）14 。例如，对于 `sale_price >= 3000`这个查询条件来说，由于 `product_name` 列为 `'运动 T 恤'` 的记录的 `sale_price` 列的值是 `2800` ，因此会返回假（`FALSE` ），而 `product_name` 列为 `'高压锅'` 的记录的 `sale_price` 列的值是 `5000` ，所以返回真（`TRUE` ）。
>
> 逻辑运算符对比较运算符等返回的真值进行操作。`AND` 运算符两侧的真值都为真时返回真，除此之外都返回假。`OR` 运算符两侧的真值只要有一个不为假就返回真，只有当其两侧的真值都为假时才返回假。`NOT` 运算符只是单纯的将真转换为假，将假转换为真。**真值表** （truth table）就是对这类操作及其结果进行的总结（表 2-4）。

### **AND**

| P    | Q    | P AND Q |
| ---- | ---- | ------- |
| 真   | 真   | 真      |
| 真   | 假   | 假      |
| 假   | 真   | 假      |
| 假   | 假   | 假      |

### **OR**

| P    | Q    | P AND Q |
| ---- | ---- | ------- |
| 真   | 真   | 真      |
| 真   | 假   | 真      |
| 假   | 真   | 真      |
| 假   | 假   | 假      |

### **NOT**

| P    | NOT P |
| ---- | ----- |
| 真   | 假    |
| 假   | 真    |

## 含有NULL时的真值

> 既不是真也不是假，那结果到底是什么呢？其实这是 SQL 中特有的情况。这时真值是除真假之外的第三种值——**不确定（UNKNOWN）** 。一般的逻辑运算并不存在这第三种值。SQL 之外的语言也基本上只使用真和假这两种真值。与通常的逻辑运算被称为**二值逻辑** 相对，只有 SQL 中的逻辑运算被称为**三值逻辑** 。

### **AND**

|   P    |   Q    | P `AND` Q |
| :----: | :----: | :-------: |
|   真   |   真   |    真     |
|   真   |   假   |    假     |
|   真   | 不确定 |  不确定   |
|   假   |   真   |    假     |
|   假   |   假   |    假     |
|   假   | 不确定 |    假     |
| 不确定 |   真   |  不确定   |
| 不确定 |   假   |    假     |
| 不确定 | 不确定 |  不确定   |

**OR**

|   P    |   Q    | P `OR` Q |
| :----: | :----: | :------: |
|   真   |   真   |    真    |
|   真   |   假   |    真    |
|   真   | 不确定 |    真    |
|   假   |   真   |    真    |
|   假   |   假   |    假    |
|   假   | 不确定 |  不确定  |
| 不确定 |   真   |    真    |
| 不确定 |   假   |  不确定  |
| 不确定 | 不确定 |  不确定  |

> 原本只有 4 行的真值表，如果要考虑 `NULL` 的话就会像表 2-6 那样增加为 3×3=9 行，看起来也变得更加繁琐，考虑 `NULL` 时的条件判断也会变得异常复杂，这与我们希望的结果大相径庭。因此，数据库领域的有识之士们达成了“尽量不使用 `NULL` ”的共识。
>
> 这就是为什么在创建 `Product` 表时要给某些列设置 `NOT NULL` 约束（禁止录入 `NULL` ）的缘故。