# 6-2 谓词

[toc]

## 什么是谓词

对通常的函数来说，返回值有可能是数字、字符串或者日期等，但是谓词的返回值全都是真值（`TRUE/FALSE/UNKNOWN` ）。这也是谓词和函数的最大区别。

本节将会介绍以下谓词。

- `LIKE`

- `BETWEEN`
- `IS NULL` 、`IS NOT NULL`
- `IN`
- `EXISTS`

## `LIKE` 谓词——字符串的部分一致查询

**`LIKE` 谓词** 更加模糊一些，当需要进行字符串的**部分一致查询** 时需要使用该谓词。

首先我们来创建一张表 6-1 那样的只有 1 列的表。

**表 6-1　S`ampleLike` 表**

| `strcol` （字符串） |
| :-----------------: |
|      `abcddd`       |
|      `dddabc`       |
|      `abdddc`       |
|       `abcdd`       |
|       `ddabc`       |
|       `abddc`       |

**代码清单 6-21　创建 `SampleLike` 表**

```sql
-- DDL ：创建表
CREATE TABLE SampleLike
( strcol VARCHAR(6) NOT NULL,
  PRIMARY KEY (strcol));

SQL Server  PostgreSQL


-- DML ：插入数据
BEGIN TRANSACTION; -------①

INSERT INTO SampleLike (strcol) VALUES ('abcddd');
INSERT INTO SampleLike (strcol) VALUES ('dddabc');
INSERT INTO SampleLike (strcol) VALUES ('abdddc');
INSERT INTO SampleLike (strcol) VALUES ('abcdd');
INSERT INTO SampleLike (strcol) VALUES ('ddabc');
INSERT INTO SampleLike (strcol) VALUES ('abddc');

COMMIT;
```

想要从该表中读取出包含字符串“`ddd` ”的记录时，可能会得到前方一致、中间一致和后方一致等不同的结果。

- **前方一致：选取出“`dddabc` ”**

  所谓**前方一致** ，就是选取出作为查询条件的字符串（这里是“`ddd` ”）与查询对象字符串起始部分相同的记录的查询方法。

- **中间一致：选取出“`abcddd` ”“`dddabc`”“`abdddc` ”**

  所谓**中间一致** ，就是选取出查询对象字符串中含有作为查询条件的字符串（这里是“`ddd` ”）的记录的查询方法。无论该字符串出现在对象字符串的最后还是中间都没有关系。

- **后方一致：选取出“`abcddd` ”**

  **后方一致** 与前方一致相反，也就是选取出作为查询条件的字符串（这里是“`ddd` ”）与查询对象字符串的末尾部分相同的记录的查询方法。

### **前方一致查询**

**代码清单 6-22　使用 `LIKE` 进行前方一致查询**

```sql
SELECT *
  FROM SampleLike
 WHERE strcol LIKE 'ddd%';
```

其中的 **`%`** 是代表“0 字符以上的任意字符串”的特殊符号，本例中代表“以 `ddd` 开头的所有字符串”。

### **中间一致查询**

**代码清单 6-23　使用 `LIKE` 进行中间一致查询**

```sql
SELECT *
  FROM SampleLike
 WHERE strcol LIKE '%ddd%';
```

### **后方一致查询**

**代码清单 6-24　使用 `LIKE` 进行后方一致查询**

```sql
SELECT *
  FROM SampleLike
 WHERE strcol LIKE '%ddd';
```

此外，我们还可以使用 **`_`** （下划线）来代替 `%` ，与 `%`不同的是，它代表了“任意 1 个字符”。下面就让我们来尝试一下吧。

使用代码清单 6-25 选取出 `strcol` 列的值为“`abc` + 任意 2 个字符”的记录。

**代码清单 6-25　使用 `LIKE` 和 `_` （下划线）进行后方一致查询**

```sql
SELECT * FROM SampleLike WHERE strcol LIKE 'abc__';
```

**代码清单 6-26　查询“`abc+` 任意 3 个字符”的字符串**

```sql
SELECT *
  FROM SampleLike
 WHERE strcol LIKE 'abc___';
```

## `BETWEEN` 谓词——范围查询

使用 **`BETWEEN`** 可以进行**范围查询** 。该谓词与其他谓词或者函数的不同之处在于它使用了 3 个参数。例如，从 `product`（商品）表中读取出销售单价（`sale_price` ）为 `100` 日元到 `1000` 日元之间的商品时，可以使用代码清单 6-27 中的 SQL 语句。

**代码清单 6-27　选取销售单价为`100` ～ `1000` 日元的商品**

```sql
SELECT product_name, sale_price
  FROM Product
 WHERE sale_price BETWEEN 100 AND 1000;
```

`BETWEEN` 的特点就是结果中会包含 `100` 和 `1000` 这两个临界值。如果不想让结果中包含临界值，那就必须使用 **`<`** 和 **`>`**（代码清单 6-28）。

**代码清单 6-28　选取出销售单价为`101` ～ `999` 日元的商品**

```sql
SELECT product_name, sale_price
  FROM Product
 WHERE sale_price > 100
   AND sale_price < 1000;
```

## `IS NULL` 、`IS NOT NULL` ——判断是否为`NULL`

为了选取出某些值为 `NULL` 的列的数据，不能使用 `=` ，而只能使用特定的谓词 **`IS NULL`** （代码清单 6-29）。

**代码清单 6-29　选取出进货单价（`purchase_price` ）为`NULL` 的商品**

```sql
SELECT product_name, purchase_price
  FROM Product
 WHERE purchase_price IS NULL;
```

与此相反，想要选取 `NULL` 以外的数据时，需要使用 **`IS NOT NULL`** （代码清单 6-30）。

**代码清单 6-30　选取进货单价（`purchase_price` ）不为 `NULL` 的商品**

```SQL
SELECT product_name, purchase_price
  FROM Product
 WHERE purchase_price IS NOT NULL;
```

## `IN` 谓词——`OR` 的简便用法

接下来让我们思考一下如何选取出进货单价（`purchase_price` ）为 `320` 日元、`500` 日元、`5000` 日元的商品。这里使用之前学过的 `OR` 的 SQL 语句，请参考代码清单 6-31。

**代码清单 6-31　通过 `OR` 指定多个进货单价进行查询**

```sql
SELECT product_name, purchase_price
FROM Product
WHERE purchase_price = 320
OR purchase_price = 500
OR purchase_price - 5000;
```

虽然上述方法没有问题，但还是存在一点不足之处，那就是随着希望选取的对象越来越多，SQL 语句也会越来越长，阅读起来也会越来越困难。这时，我们就可以使用代码清单 6-32 中的 **`IN` 谓词** “`IN( 值,……)` ”来替换上述 SQL 语句

**代码清单 6-32　通过 `IN` 来指定多个进货单价进行查询**

```sql
SELECT product_name, purchase_price
  FROM Product
 WHERE purchase_price IN (320, 500, 5000);
```

**代码清单 6-33　使用`NOT IN` 进行查询时指定多个排除的进货单价进行查询**

```sql
SELECT product_name, purchase_price
  FROM Product
 WHERE purchase_price NOT IN (320, 500, 5000);
```

但需要注意的是，在使用 `IN` 和 `NOT IN` 时**是无法选取出 `NULL` 数据的** 。实际结果也是如此，上述两组结果中都不包含进货单价为 `NULL` 的叉子和圆珠笔。`NULL` 终究还是需要使用 `IS NULL` 和 `IS NOT NULL` 来进行判断。

## 使用子查询作为 `IN` 谓词的参数

让我们再添加一张新表。之前我们使用的全都是显示商品库存清单的 `Product`（商品）表，但现实中这些商品可能只在个别的商店中进行销售。下面我们来创建表 6-2 `ShopProduct` （商店商品），显示出哪些商店销售哪些商品。

**表 6-2　`ShopProduct` （商店商品）表**

| `shop_id（商店）` | `shop_name（商店名称）` | `product_id（商品编号）` | `quantity（数量）` |
| :---------------: | :---------------------: | :----------------------: | :----------------: |
|      `000A`       |          东京           |          `0001`          |        `30`        |
|      `000A`       |          东京           |          `0002`          |        `50`        |
|      `000A`       |          东京           |          `0003`          |        `15`        |
|      `000B`       |         名古屋          |          `0002`          |        `30`        |
|      `000B`       |         名古屋          |          `0003`          |       `120`        |
|      `000B`       |         名古屋          |          `0004`          |        `20`        |
|      `000B`       |         名古屋          |          `0006`          |        `10`        |
|      `000B`       |         名古屋          |          `0007`          |        `40`        |
|      `000C`       |          大阪           |          `0003`          |        `20`        |
|      `000C`       |          大阪           |          `0004`          |        `50`        |
|      `000C`       |          大阪           |          `0006`          |        `90`        |
|      `000C`       |          大阪           |          `0007`          |        `70`        |
|      `000D`       |          福冈           |          `0001`          |       `100`        |

商店和商品组合成为一条记录。例如，该表显示出东京店销售的商品有 `0001` （T 恤衫）、`0002` （打孔器）、`0003` （运动 T 恤）三种。

**代码清单 6-34　创建`ShopProduct` （商店商品）表的`CREATE TABLE` 语句**

```sql
CREATE TABLE ShopProduct
(shop_id    CHAR(4)      NOT NULL,
 shop_name  VARCHAR(200) NOT NULL,
 product_id CHAR(4)      NOT NULL,
 quantity   INTEGER      NOT NULL,
 PRIMARY KEY (shop_id, product_id));
```

> 该 `CREATE TABLE` 语句的特点是指定了 2 列作为主键（primary key）。这样做当然还是为了区分表中每一行数据，由于单独使用商店编号（`shop_id` ）或者商品编号（`product_id` ）不能满足要求，因此需要对商店和商品进行组合。
>
> 实际上如果只使用商店编号进行区分，那么指定“`000A` ”作为条件能够查询出 3 行数据。而单独使用商品编号进行区分的话，“`0001` ”也会查询出 2 行数据，都无法恰当区分每行数据。

**代码清单 6-35　向 `ShopProduct` 表中插入数据的 `INSERT` 语句**

```sql
BEGIN TRANSACTION; --------①
INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES ('000A', '东京', '0001', 30);
INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES ('000A', '东京', '0002', 50);
INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES ('000A', '东京', '0003', 15);
INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES ('000B', '名古屋', '0002', 30);
INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES ('000B', '名古屋', '0003', 120);
INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES ('000B', '名古屋', '0004', 20);
INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES ('000B', '名古屋', '0006', 10);
INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES ('000B', '名古屋', '0007', 40);
INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES ('000C', '大阪', '0003', 20);
INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES ('000C', '大阪', '0004', 50);
INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES ('000C', '大阪', '0006', 90);
INSERT INTO ShopProduct (shop_id, shop_name, product_id, quantity) VALUES ('000C', '大阪', '0007', 70);
INSERT INTO ShopProduct (shop_id, shop_name,
product_id, quantity) VALUES ('000D', '福冈', '0001', 100);

COMMIT;
```

首先读取出“大阪店（`000C` ）在售商品（`product_id` ）的销售单价（`sale_price` ）”。

`ShopProduct` （商店商品）表中大阪店的在售商品很容易就能找出， 有如下 4 种。

- 运动 T 恤（商品编号 ：`0003` ）
- 菜刀（商品编号 ：`0004` ）
- 叉子（商品编号 ：`0006` ）
- 擦菜板（商品编号 ：`0007` ）

> 1. 从 `ShopProduct` 表中选取出在大阪店（`shop_id = '000C'` ）中销售的商品（`product_id` ）
> 2. 从 `Product` 表中选取出上一步得到的商品（`product_id` ）的销售单价（`sale_price` ）

SQL 也是如此，同样要分两步来完成。首先，第一步如下所示。

```SQL
SELECT product_id
  FROM ShopProduct
 WHERE shop_id = '000C';
```

因为大阪店的商店编号（`shop_id` ）是“`000C` ”，所以我们可以将其作为条件写在 `WHERE` 子句中 10 。接下来，我们就可以把上述 `SELECT` 语句作为第二步中的条件来使用了。最终得到的 `SELECT` 语句请参考代码清单 6-36。

```sql
SELECT product_name, sale_price
FROM Product
WHERE product_id IN (SELECT product_id
                    FROM ShopProduct
                    WHERE shop_id = '000C');
```

- **`NOT IN` 和子查询**

  `IN` 的否定形式 `NOT IN` 同样可以使用子查询作为参数，其语法也和 `IN` 完全一样。请大家参考代码清单 6-37 中的例文。

  **代码清单 6-37　使用子查询作为 `NOT IN` 的参数**

  ```sql
  SELECT product_name, sale_price
    FROM Product
   WHERE product_id NOT IN (SELECT product_id
                               FROM ShopProduct
                             WHERE shop_id = '000A');
  ```

  我们也像之前那样来看一下该 SQL 的执行步骤。因为还是首先执行子查询，所以会得到如下结果。

  ```sql
  SELECT product_name, sale_price
    FROM Product
   WHERE product_id NOT IN ('0001', '0002', '0003');
  ```

## `EXIST` 谓词

① `EXIST` 的使用方法与之前的都不相同

② 语法理解起来比较困难

③ 实际上即使不使用 `EXIST` ，基本上也都可以使用 `IN` （或者 `NOT IN` ）来代替

### **`EXIST` 谓词的使用方法**

一言以蔽之，谓词的作用就是“判断是否存在满足某种条件的记录”。如果存在这样的记录就返回真（`TRUE`），如果不存在就返回假（`FALSE` ）。 `EXIST` （存在）谓词的主语是“记录”。

我们继续使用前一节“`IN` 和子查询”中的示例，使用 `EXIST` 选取出“大阪店（`000C` ）在售商品（`product_id` ）的销售单价（`sale_price` ）”。

**代码清单 6-38　使用 `EXIST` 选取出“大阪店在售商品的销售单价”**

```sql
SELECT product_name, sale_price
  FROM Product AS P -----------------------①
 WHERE EXISTS (SELECT *
                  FROM ShopProduct AS SP --②
                 WHERE SP.shop_id = '000C'
				AND SP.product_id = P.product_id);
```

- **`EXIST` 的参数**

  之前我们学过的谓词，基本上都是像“列 `LIKE`字符串”或者“列 `BETWEEN` 值 1 `AND` 值 2”这样需要指定 2 个以上的参数，而 `EXIST` 的左侧并没有任何参数。很奇妙吧？这是因为 `EXIST` 是只有 1 个参数的谓词。`EXIST` 只需要在右侧书写 1 个参数，该参数通常都会是一个子查询。

  ```SQL
  (SELECT *
     FROM ShopProduct AS SP
    WHERE SP.shop_id = '000C'
    AND SP.product_id = P.product_id);
  ```

  上面这样的子查询就是唯一的参数。确切地说，由于通过条件“`SP.product_id = P.product_id` ”将 `Product` 表和 `ShopProduct` 表进行了联接，因此作为参数的是关联子查询。`EXIST` 通常都会使用关联子查询作为参数 12 。

> 通常指定关联子查询作为`EXIST` 的参数。

- **子查询中的 `SELECT \*`**

  能大家会觉得子查询中的 `SELECT *` 稍微有些不同，就像我们之前学到的那样，由于 `EXIST` 只关心记录是否存在，因此返回哪些列都没有关系。`EXIST` 只会判断是否存在满足子查询中 `WHERE` 子句指定的条件“商店编号（`shop_id` ）为 `'000C'` ，商品（`Product` ）表和商店商品（`ShopProduct` ）表中商品编号（`product_id` ）相同”的记录，只有存在这样的记录时才返回真（`TRUE` ）。

  因此，即使写成代码清单 6-39 那样，结果也不会发生改变。

  **代码清单 6-39　这样的写法也能得到与代码清单 6-38 相同的结果**

  ```SQL
  SELECT product_name, sale_price
    FROM Product AS P ------------------------------①
   WHERE EXISTS (SELECT 1 -- 这里可以书写适当的常数
                    FROM ShopProduct AS SP ---------②
                   WHERE SP.shop_id = '000C'
                     AND SP.product_id = P.product_id);
  ```

- **使用 `NOT EXIST` 替换 `NOT IN`**

  就像 `EXIST` 可以用来替换 `IN` 一样，`NOT IN` 也可以用 **`NOT EXIST`** 来替换。下面就让我们使用 `NOT EXIST` 来编写一条 `SELECT` 语句

  读取出“东京店（`000A` ）在售之外的商品（`product_id` ）的销售单价（`sale_price`）”（代码清单 6-40）。

  **代码清单 6-40　使用 `NOT EXIST` 读取出“东京店在售之外的商品的销售单价”**

  ```SQL
  SQL Server  DB2  PostgreSQL  MySQL
  
  
  SELECT product_name, sale_price
    FROM Product AS P ----------------------------①
   WHERE NOT EXISTS (SELECT *
                        FROM ShopProduct AS SP ---②
                       WHERE SP.shop_id = '000A'
                         AND SP.product_id = P.product_id);
  ```
  
  > 将 `IN` （代码清单 6-36）和 `EXIST` （代码清单 6-38）的 `SELECT` 语句进行比较，会得到怎样的结果呢？可能大多数读者会觉得 `IN` 理解起来要容易一些，笔者也认为没有必要勉强使用 `EXIST` 。因为 `EXIST` 拥有 `IN` 所不具有的便利性，严格来说两者并不相同，所以希望大家能够在中级篇中掌握这两种谓词的使用方法。

