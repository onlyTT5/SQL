# 5-2 子查询

[toc]

## 子查询和视图

>  我们先来复习一下视图的概念，视图并不是用来保存数据的，而是通过保存读取数据的 `SELECT` 语句的方法来为用户提供便利。反之，子查询就是将**用来定义视图的 `SELECT` 语句** 直接用于 `FROM` 子句当中。

**代码清单 5-8　视图`ProductSum` 和确认用的`SELECT` 语句**

```sql
-- 根据商品种类统计商品数量的视图
CREATE VIEW ProductSum (product_type, cnt_product)
AS
SELECT product_type, COUNT(*)
  FROM Product
 GROUP BY product_type;

-- 确认创建好的视图
SELECT product_type, cnt_product
  FROM ProductSum;
```

**代码清单 5-9　子查询**

```sql
SELECT product_type, cnt_product
FROM (SELECT product_type, COUNT(*) AS cnt_product
FROM Product
GROUP BY product_type) AS ProductSum;
```

**图5-4　`SELECT` 语句的执行顺序**

![{%}](D:/GitRep/SQL/notes/%E7%AC%AC5%E7%AB%A0%20%E5%A4%8D%E6%9D%82%E6%9F%A5%E8%AF%A2/5-2%20%E5%AD%90%E6%9F%A5%E8%AF%A2.assets/Image00103.gif)

① 首先执行 `FROM` 子句中的 `SELECT` 语句（子查询）

```sql
SELECT product_type, COUNT(*) AS cnt_product
  FROM Product
 GROUP BY product_type;
```

② 根据①的结果执行外层的 `SELECT` 语句

```sql
SELECT product_type, cnt_product
  FROM ProductSum;
```

> 子查询作为内层查询会首先执行。

- **增加子查询的层数**

  由于子查询的层数原则上没有限制，因此可以像“子查询的 `FROM` 子句中还可以继续使用子查询，该子查询的 `FROM` 子句中还可以再使用子查询……”这样无限嵌套下去（代码清单 5-10）。

  ```sql
  SQL Server  DB2  PostgreSQL  MySQL
  
  
  SELECT product_type, cnt_product
    FROM (SELECT *
            FROM (SELECT product_type, COUNT(*) AS cnt_product
                    FROM Product
                   GROUP BY product_type) AS ProductSum -----①
           WHERE cnt_product = 4) AS ProductSum2; -----------②
  ```

> 最内层的子查询（`ProductSum` ）与之前一样，根据商品种类（`product_type` ）对数据进行汇总，其外层的子查询将商品数量（`cnt_product` ）限定为 4，结果就得到了 1 行厨房用具的数据。
>
> 但是，随着子查询嵌套层数的增加，SQL 语句会变得越来越难读懂，性能也会越来越差。因此，请大家尽量避免使用多层嵌套的子查询。

## 子查询的名称

> 为子查询设定名称时需要使用 `AS` 关键字，该关键字有时也可以省略。

## 标量子查询

- **什么是标量**

  **标量** 就是单一的意思，在数据库之外的领域也经常使用。

> 标量子查询就是返回单一值的子查询。

- **在 `WHERE` 子句中使用标量子查询**

  查询出销售单价高于平均销售单价的商品。

  然而这并不是用普通方法就能解决的。如果我们像下面这样使用 `AVG` 函数的话，就会发生错误。

  ```sql
  SELECT product_id, product_name, sale_price
  FROM Product
  WHERE sale_price > AVG(sale_price);
  ```

  这时标量子查询就可以发挥它的功效了。

  **代码清单 5-11　计算平均销售单价的标量子查询**

  ```sql
  SELECT AVG(sale_price)
    FROM Product;
  ```

  **代码清单 5-12　选取出销售单价（`sale_price` ）高于全部商品的平均单价的商品**

  ```sql
  SELECT product_id, product_name, sale_price
  FROM Product
  WHERE sale_price > (SELECT AVG(sale_price) FROM Product);
  ```

  前一节我们已经介绍过，使用子查询的 SQL 会从子查询开始执行。因此，这种情况下也会先执行下述计算平均单价的子查询

  ```sql
  -- ① 内层的子查询
  SELECT AVG(sale_price)
    FROM Product ；
  ```

  ```sql
  -- ② 外层的查询
  SELECT product_id, product_name, sale_price
    FROM Product
   WHERE sale_price > 2097.5
  ```

  **图5-5　`SELECT` 语句的执行顺序（标量子查询）**

  ![{%}](D:/GitRep/SQL/notes/%E7%AC%AC5%E7%AB%A0%20%E5%A4%8D%E6%9D%82%E6%9F%A5%E8%AF%A2/5-2%20%E5%AD%90%E6%9F%A5%E8%AF%A2.assets/Image00106-16607944193038.gif)

## 标量子查询的书写位置

标量子查询的书写位置并不仅仅局限于 `WHERE` 子句中，通常任何可以使用单一值的位置都可以使用。也就是说，**能够使用常数或者列名的地 方，无论是 `SELECT` 子句、`GROUP BY`子句、`HAVING` 子句，还是 `ORDER BY` 子句，几乎所有的地方都可以使用** 。

**代码清单 5-13　在 `SELECT` 子句中使用标量子查询**

```sql
SELECT product_id, product_name, sale_price, (SELECT AVG(sale_price)
AS avg_price)
FROM Product;
```

此外，我们还可以像代码清单 5-14 中的 `SELECT` 语句那样，在 `HAVING` 子句中使用标量子查询。

该查询的含义是想要选取出按照商品种类计算出的销售单价高于全部商品的平均销售单价的商品种类。

**代码清单 5-14　在 `HAVING` 子句中使用标量子查询**

```sql
SELECT product_type, AVG(sale_price)
FROM Product
GROUP BY product_type
HAVING AVG(sale_price) > (SELECT AVG(sale_price) FROM Product);
```

但是，由于全部商品的平均销售单价是 `2097.5` 日元，因此低于该平均值的办公用品会被 `HAVING` 子句中的条件排除在外。

## 使用标量子查询时的注意事项

**该子查询绝对不能返回多行结果** 。

```sql
SELECT product_id, product_name, sale_price, (SELECT AVG(sale_price) FROM Product GROUP BY product_type) AS avg_price
FROM Product;
```

