# 5-3 关联子查询

[toc]

## 普通的子查询和关联子查询的区别

选取出各商品种类中高于该商品种类的平均销售单价的商品。

- **按照商品种类与平均销售单价进行比较**

**代码清单 5-15　按照商品种类计算平均价格**

```SQL
SELECT AVG(sale_price)
  FROM Product
 GROUP BY product_type;
```

但是，如果我们使用前一节（标量子查询）的方法，直接把上述 `SELECT` 语句使用到 `WHERE` 子句当中的话，就会发生错误。

```SQL
-- 发生错误的子查询
SELECT product_id, product_name, sale_price
  FROM Product
 WHERE sale_price > (SELECT AVG(sale_price)
                          FROM Product
                         GROUP BY product_type);
```

出错原因前一节已经讲过了，该子查询会返回 3 行结果（2795、2500、300），并不是标量子查询。

- **使用关联子查询的解决方案**

  只需要在刚才的 `SELECT` 语句中追加一行，就能得到我们想要的结果了

  **代码清单 5-16　通过关联子查询按照商品种类对平均销售单价进行比较**

  ```sql
  SELECT product_type, product_name, sale_price 
  FROM Product AS P1
  WHERE sale_price > (SELECT AVG(sale_price)
  FROM Product AS P2
  WHERE P1.product_type = P2.product_type
  GROUP BY product_type);
  ```

  > 这样我们就能选取出办公用品、衣服和厨房用具三类商品中高于该类商品的平均销售单价的商品了。

  这里起到关键作用的就是**在子查询中添加的 `WHERE` 子句的条件** 。该条件的意思就是，**在同一商品种类中** 对各商品的销售单价和平均单价进行比较。

## 关联子查询也是用来对集合进行切分的

换个角度来看，其实关联子查询也和 `GROUP BY` 子句一样，可以对集合进行切分。

**图5-6　根据商品种类对表进行切分的图示**

![img](D:/GitRep/SQL/notes/%E7%AC%AC5%E7%AB%A0%20%E5%A4%8D%E6%9D%82%E6%9F%A5%E8%AF%A2/5-3%20%E5%85%B3%E8%81%94%E5%AD%90%E6%9F%A5%E8%AF%A2.assets/Image00111-16609156421833.gif)

**图5-7　根据关联子查询进行切分的图示**

![img](D:/GitRep/SQL/notes/%E7%AC%AC5%E7%AB%A0%20%E5%A4%8D%E6%9D%82%E6%9F%A5%E8%AF%A2/5-3%20%E5%85%B3%E8%81%94%E5%AD%90%E6%9F%A5%E8%AF%A2.assets/Image00112-166091633851811.gif)

我们首先需要计算各个商品种类中商品的平均销售单价，由于该单价会用来和商品表中的各条记录进行比较，因此关联子查询实际只能返回 1 行结果。

**图5-8　关联子查询执行时DBMS内部的执行情况**

![{%}](D:/GitRep/SQL/notes/%E7%AC%AC5%E7%AB%A0%20%E5%A4%8D%E6%9D%82%E6%9F%A5%E8%AF%A2/5-3%20%E5%85%B3%E8%81%94%E5%AD%90%E6%9F%A5%E8%AF%A2.assets/Image00113-166091637681816.gif)

## 结合条件一定要写在子查询中

```sql
SELECT product_type, product_name, sale_price 
FROM Product AS P1
WHERE P1.product_type = P2.product_type
AND sale_price > (SELECT AVG(sale_price)
FROM Product AS P2
GROUP BY product_type);
```

上述 `SELECT` 语句只是将子查询中的关联条件移到了外层查询之中，其他并没有任何更改。但是，该 `SELECT` 语句会发生错误，不能正确执行。