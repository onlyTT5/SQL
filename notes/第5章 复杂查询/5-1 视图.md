# 5-1 视图

[toc]

## 视图和表

我们首先要学习的是一个新的工具——**视图** 。

> 通常，我们在创建表时，会通过 `INSERT` 语句将数据保存到数据库之中，而数据库中的数据实际上会被保存到计算机的**存储设备** （通常是硬盘）中。因此，我们通过 `SELECT` 语句查询数据时，实际上就是从存储设备（硬盘）中读取数据，进行各种计算之后，再将结果返回给用户这样一个过程。
>
> 但是使用视图时并不会将数据保存到存储设备之中，而且也**不会将数据保存到其他任何地方** 。实际上视图保存的是 `SELECT` 语句（图 5-1）。我们从视图中读取数据时，视图会在内部执行该 `SELECT` 语句并创建出一张临时表。

**图5-1　视图和表**

![{%}](D:/GitRep/SQL/notes/%E7%AC%AC5%E7%AB%A0%20%E5%A4%8D%E6%9D%82%E6%9F%A5%E8%AF%A2/5-1%20%E8%A7%86%E5%9B%BE.assets/Image00091.gif)

- **视图的优点**

  1. 视图的优点大体有两点。第一点是由于视图==无需保存数据==，因此可以节省存储设备的容量。例如，我们在 4-1 节中创建了用来汇总商品种类（`product_type` ）的表。由于该表中的数据最终都会保存到存储设备之中，因此会占用存储设备的数据空间。但是，如果把同样的数据作为视图保存起来的话，就只需要代码清单 5-1 那样的 `SELECT` 语句就可以了，这样就节省了存储设备的数据空间。

     **代码清单 5-1　通过视图等 `SELECT` 语句保存数据**

     ```sql
     SELECT product_type, SUM(sale_price), SUM(purchase_price)
       FROM Product
      GROUP BY product_type;
     ```

     由于本示例中表的数据量充其量只有几行，所以使用视图并不会大幅缩小数据的大小。但是在实际的业务中数据量往往非常大，这时使用视图所节省的容量就会非常可观了。

     表中存储的是实际数据，而视图中保存的是从表中取出数据所使用的`SELECT` 语句。

  2. 第二个优点就是可以将频繁使用的 `SELECT` 语句保存成视图，这样就不用每次都重新书写了。创建好视图之后，只需在 `SELECT` 语句中进行调用，就可以方便地得到想要的结果了。特别是在进行汇总以及复杂的查询条件导致 `SELECT` 语句非常庞大时，使用视图可以大大提高效率。

     而且，视图中的数据会随着原表的变化自动更新。视图归根到底就是 `SELECT` 语句，所谓“参照视图”也就是“执行 `SELECT` 语句”的意思，因此可以保证数据的最新状态。这也是将数据保存在表中所不具备的优势 

> 应该将经常使用的`SELECT` 语句做成视图。

## 创建视图的方法

**语法 5-1　创建视图的`CREATE VIEW` 语句**

```sql
CREATE VIEW 视图名称(<视图列名1>, <视图列名2>, ……)
AS
<SELECT语句>
```

**代码清单 5-2　`ProductSum` 视图**

```sql
CREATE VIEW ProductSum (product_type, cnt_product)
AS
SELECT product_type, COUNT(*)
FROM Product
GROUP BY product_type;
```

> 请大家一定不要省略第 2 行的关键字 `AS`。这里的 `AS` 与定义别名时使用的 `AS` 并不相同，如果省略就会发生错误。虽然很容易混淆，但是语法就是这么规定的，所以还是请大家牢记。

### 视图的使用方法

```sql
SELECT product_type, cnt_product
FROM ProductSum;
```

> 通过上述视图 `ProductSum` 定义的主体（`SELECT` 语句）我们可以看出，该视图将根据商品种类（`product_type` ）汇总的商品数量（`cnt_product` ）作为结果保存了起来。这样如果大家在工作中需要频繁进行汇总时，就不用每次都使用 `GROUP BY` 和 `COUNT` 函数写 `SELECT` 语句来从 `Product`表中取得数据了。创建出视图之后，就可以通过非常简单的 `SELECT` 语句，随时得到想要的汇总结果。并且如前所述，`Product` 表中的数据更新之后，视图也会自动更新，非常灵活方便。
>
> 之所以能够实现上述功能，是因为**视图就是保存好的 `SELECT` 语句** 。定义视图时可以使用任何 `SELECT` 语句，既可以使用 `WHERE` 、`GROUP BY` 、`HAVING` ，也可以通过 `SELECT *` 来指定全部列。

- **使用视图的查询**

  在 `FROM` 子句中使用视图的查询，通常有如下两个步骤：

  1. 首先执行定义视图的 `SELECT` 语句
  2. 根据得到的结果，再执行在 `FROM` 子句中使用视图的 `SELECT` 语句

  这里没有使用“2 条”而使用了“2 条以上”，是因为还可能出现以视图为基础创建视图的**多重视图**

  **图5-2　可以在视图的基础上创建视图**

![{%}](D:/GitRep/SQL/notes/%E7%AC%AC5%E7%AB%A0%20%E5%A4%8D%E6%9D%82%E6%9F%A5%E8%AF%A2/5-1%20%E8%A7%86%E5%9B%BE.assets/Image00094-1660785256489132.gif)

**代码清单 5-4　视图`ProductSumJim** `

```SQL
CREATE VIEW ProductJim (product_type, cnt_product)
AS
SELECT product_type, cnt_product
FROM ProductSum
WHERE product_type = '办公用品';
```

虽然语法上没有错误，但是我们还是应该尽量避免在视图的基础上创建视图。这是因为对多数 DBMS 来说，**多重视图会降低 SQL 的性能** 。因此，希望大家（特别是刚刚接触视图的读者）能够使用单一视图。

> 应该避免在视图的基础上创建视图。

## 视图的限制①——定义视图时不能使用 `ORDER BY`子句

> 定义视图时不要使用`ORDER BY` 子句。

## 视图的限制② ——对视图进行更新

1. SELECT` 子句中未使用 `DISTINCT
2. `FROM` 子句中只有一张表
3. 未使用 `GROUP BY` 子句
4. 未使用 `HAVING` 子句

简单来说，像这次的例子中使用的 `ProductSum` 那样，使用视图来保存原表的汇总结果时，是无法判断如何将视图的更改反映到原表中的。

例如，对 `ProductSum` 视图执行如下 `INSERT` 语句。

```sql
INSERT INTO ProductSum VALUES ('电器制品', 5);
```

使用前述 `INSERT` 语句，向视图 `ProductSum` 中添加数据 `(' 电器制品 ',5)` 时，原表 `Product` 应该如何更新才好呢？按理说应该向表中添加商品种类为“电器制品”的 5 行数据，但是这些商品对应的商品编号、商品名称和销售单价等我们都不清楚（图 5-3）。数据库在这里就遇到了麻烦。

![{%}](D:/GitRep/SQL/notes/%E7%AC%AC5%E7%AB%A0%20%E5%A4%8D%E6%9D%82%E6%9F%A5%E8%AF%A2/5-1%20%E8%A7%86%E5%9B%BE.assets/Image00097-1660786162691138.gif)

> 视图和表需要同时进行更新，因此通过汇总得到的视图无法进行更新。

- **能够更新视图的情况**

**代码清单 5-5　可以更新的视图**

```sql
CREATE VIEW ProductJim (product_id, product_name, product_type, sale_price, purchase_price, regist_date)
AS
SELECT *
FROM Product
WHERE product_type = '办公用品';
```

对于上述只包含办公用品类商品的视图 `ProductJim`来说，就可以执行类似代码清单 5-6 这样的 `INSERT`语句。

```sql
INSERT INTO ProductJim VALUES ('0009', '印章', '办公用品', 95, 10, '2009-11-30');
```

由于**PostgreSQL** 中的视图会被初始设定为只读，所以执行代码清单5-6中的`INSERT` 语句时，会发生下面这样的错误。

**执行结果（使用PostgreSQL）**

```sql
ERROR:  不能向视图中插入数据
HINT:  需要一个无条件的ON INSERT DO INSTEAD规则
```

这种情况下，在`INSERT` 语句执行之前，需要使用代码清单5-A中的指令来允许更新操作。在DB2和 MySQL 等其他 DBMS 中，并不需要执行这样的指令。

**代码清单5-A　允许PostgreSQL对视图进行更新**

```sql
CREATE OR REPLACE RULE insert_rule
AS ON INSERT
TO  ProductJim DO INSTEAD
INSERT INTO Product VALUES (
            new.product_id,
            new.product_name,
            new.product_type,
            new.sale_price,
            new.purchase_price,
            new.regist_date);
```

下面让我们使用 `SELECT` 语句来确认数据行是否添加成功吧。

```sql
-- 确认数据是否已经添加到视图中
SELECT * FROM ProductJim;
```

```sql
-- 确认数据是否已经添加到原表中
SELECT * FROM Product;
```

`UPDATE` 语句和 `DELETE` 语句当然也可以像操作表时那样正常执行，但是对于原表来说却需要设置各种各样的约束（主键和 `NOT NULL` 等），需要特别注意。

## 删除视图

删除视图需要使用 **`DROP VIEW` 语句** ，其语法如下所示。

**语法 5-2　删除视图的DROP VIEW语句**

```sql
DROP VIEW 视图名称(<视图列名1>, <视图列名2>, ……)
```

**代码清单 5-7　删除视图**

```sql
DROP VIEW ProductSum;
```

在 **PostgreSQL** 中，如果删除以视图为基础创建出来的多重视图，由于存在关联的视图，因此会发生如下错误。

**执行结果（使用PostgreSQL）**

```sql
ERROR:   由于存在关联视图，因此无法删除视图productsum
DETAIL:  视图productsumjim与视图productsum相关联
HINT:    删除关联对象请使用DROP…CASCADE
```

这时可以像下面这样，使用CASCADE选项来删除关联视图。

```sql
PostgreSQL


DROP VIEW ProductSum CASCADE;
```